// 1) Создать класс базовый класс «точка на плоскости».
//Элементы класса:
//поля, задающие координаты точки (вещественные поля статус доступа
//protected);
//конструктор для инициализации полей;
//метод для печати значений полей.
//Создать производный класс «точка в трехмерном пространстве».
//Элементы класса:
//дополнительное поле, задающее дополнительную координату;
//конструктор для инициализации полей;
//переопределенный метод для печати значений полей (внутри
//переопределенного метода в первую очередь должен вызываться метод из
//базового класса).
//Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
//имеющею тип базового класса, вначале настроить ее на объект базового
//класса, вызвать метод базового класса через указатель на объект. Затем
//настроить ее на объект производного класса, вызвать метод производного
//класса через указатель на объект. Обеспечить динамический полиморфизм.
#include <iostream>

class Point2D {
protected:
    double x, y;
public:
    Point2D(double x, double y) : x(x), y(y) {};

    virtual void print() const {
        std::cout << "(" << x << ", " << y << ")" << std::endl;
    }
};

class Point3D : public Point2D {
protected:
    double z;
public:
    Point3D(double x, double y, double z) : Point2D(x, y), z(z) {};


    virtual void print() const {
        Point2D::print();
        std:: cout << "(" << z << ")"<< std::endl;
    }


};



int main () {
    //Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
//имеющею тип базового класса, вначале настроить ее на объект базового
//класса, вызвать метод базового класса через указатель на объект. Затем
//настроить ее на объект производного класса, вызвать метод производного
//класса через указатель на объект. Обеспечить динамический полиморфизм.

//С помощью простых переопределенных функций
//реализуется механизм статического полиморфизма. (Полиморфизм –
//возможность функции в производном классе работать по-другому).

//Суть статического связывания: когда указатель одного типа ссылается на
//объект другого типа при наследовании классов, то выбор переопределенного
//метода определяется типом указателя, а не типом объекта.

//Суть динамического связывания: когда указатель одного типа ссылается на
//объект другого типа при наследовании классов, то выбор переопределенного
//метода определяется типом объекта, а не типом указателя, для этого
//переопределенный метод должен быть объявлен виртуальным в базовом классе


    Point2D point2D(1,2);
    Point3D point3D(1,2,3);

    Point2D *pPoint = &point2D;

    pPoint->print();

    pPoint = &point3D;

    pPoint->print();





}