### 1. Классы в языке Си++: объявление, поля и функции (методы) классов. Определение функций внутри класса и за пределами класса, примеры.

```c++
Класс в языке Си++ – это новый тип, определяемый программистом, включающий
данные (поля класса) и методы (функции) для обработки этих данных. Переменные этого
типа называются объектами.

Формат объявления класса:
<Ключевое слово> <Имя_класса>
{
 <список компонент>
};
В качестве ключевого слова используется одно из трех ключевых слов:
- struct
- class
- union

Можно дать такое определение класса через структуру, которая была в языке Си.
Класс – это структура, в которую введены методы для обработки полей.

Объекты – это переменные типа класса. 
Формат определения объектов:
<Имя_класса> <Имя_объекта1>,…<Имя_объекта_N>;

Обращение к полям и методам класса внутри методов класса просто по имени, 
а за пределами класса через имя объекта и операцию «.» 
или через имя указателя на объект и операцию «->». 
Каждый объект класса имеет в оперативной памяти свои копии полей класса.

Пример работы с полями:
struct A { int i; void print() { printf(“i=%d”, i); } };
A a1; A *pA=&a1;
a1.i=10; a1.print(); pA->i=10; pA->print();
a1.A::i=10; a1.A::print(); pA->A::i=10; pA->A::print();
```
```c++
Компонентные данные и функции класса
Компонентные данные (поля класса) и функции класса (методы класса) уже во
многом рассмотрены выше. Следует добавить, что методы класса могут быть определены
внутри класса, в этом случае они по возможности (если нет ограничений) являются
подставляемыми, но чаще всего класс содержит описание (заголовки) методов, а
определения методов находятся за пределами класса. Эта возможность является удобной в
проектах, состоящих из многих файлов. Создается отдельный файл с расширением .h
(заголовочный файл), в котором находится описание класса вместе с полями и
заголовками методов. Определения методов находится в файле реализации класса (файле
с расширением .cpp). В этом случае, чтобы использовать класс в другом файле с
исходным кодом, необходимо подключить заголовочный файл с описанием класса. Также
внутри методов можно использовать умалчиваемые значения параметров (требования
такие же, как к обычным функциям). В классах возможна перегрузка методов.
В следующем примере показаны перечисленные возможности:
```

```c++
struct Complex {
    double real,  
    image; // Поля класса 
    void define(double re=0.0, double im=0.0) 
    // Определение метода внутри класса, метод  будет  подставляемым
    {
        real=re; image=im;// Обращение к полям внутри метода
    }
    void print(); // Описание метода
};
void Complex::print() // Определение метода за пределами класса
{
    printf("\nreal=%f  image=%f", real, image); 
}
```

### 2. Статусы доступа компонент класса. Операции для доступа к компонентам класса, примеры.
```c++
Доступность компонент класса
Свойство доступности определяет возможность доступа к полям и методам за
пределами класса (через имя объекта или через указатель на объект).
Существуют три статуса доступа:
• public (полностью доступны за пределами класса);
• private (не доступны за пределами класса, можно обращаться к компонентам
только в методах своего класса);
• protected (доступны только в своем классе и в производных классах).
По умолчанию, если класс определен с ключевым словом struct, то все компоненты
имеют статус доступа public. Если с ключевым словом union, тоже public, но все поля
каждого объекта располагаются в памяти, начиная с одного адреса. Если класс определен
с ключевым словом class, то все поля и методы по умолчанию имеют статус доступа
private.
Статус доступа можно изменить с помощью соответствующих модификаторов, что
продемонстрировано в следующем примере:
struct A
{
 …… // Статус доступа public
private:
………. // Статус доступа private
protected:
……….// Статус доступа protected
};
class B
{
 …… // Статус доступа private
public:
………. // Статус доступа public
protected:
……….// Статус доступа protected
}; 
```


### 3. Конструкторы и деструктор класса, конструктор копирования и конструктор перемещения, назначение, пример.
```c++
Конструктор класса – специальный блок операторов (инструкций), вызываемый
при создании объекта. Назначение: присвоение начальных значений полям, выделение
памяти, открытие файлов, сетевых соединений и т.п. Имя конструктора совпадает с
именем класса, конструктор не имеет возвращаемого значения. Возможна перегрузка
конструкторов. Конструктор может определяться как внутри класса, так и за пределами.
Формат определения конструктора внутри класса:
Имя_класса(Список_формальных_параметров)
{ Операторы_тела конструктора }
По умолчанию класс всегда имеет конструктор копирования вида A(A& a) {… } (A –
имя класса), создающий копию объекта (происходит копирование полей), и если нет
явного конструктора, то по умолчанию создается конструктор без параметров. Эти
конструкторы можно переопределять.
Примеры вызовов конструкторов:
A a1; A* pA=new A; // Вызываются конструкторы без параметров
A a2(3, 4); A * pA2=new A(3, 4);
// Вызываются конструкторы с 2-мя параметрами
Для конструктора с одним параметром можно использовать форму:
A a1=5; A a2=a1; вместо A a1(5); A a2(a1);
```
```c++
Деструктор – специальный блок операторов (инструкций), служащий для
деинициализации объекта (освобождение памяти, закрытие файлов и т.п.).
Вызывается автоматически при удаление объекта, например, оператором delete или
при выходе из блока, в котором существует объект. Не имеет возвращаемого значения и
параметров. Может определяться как внутри класса, так и за пределами. Пример
деструктора:
~имя_класса() 
{
 тело_деструктора
}
```

### 4. Статические компоненты класса, назначение, пример.


### 5. Указатель this, примеры использования.
##### Указатель `this`
Иногда при вызове нестатического метода требуется обращаться к адресу объекта, для которого вызывается метод. Но когда программист пишет код метода класса, объектов еще не существует. Для этих целей любой нестатический метод и конструкторы (деструктор) неявно (по умолчанию) получает указатель `this` – указатель на объект класса, для которого вызывается метод.
```c++
Первый случай использования this

class point { 
    int x,y; 
public: 
    point(int x, int y) 
    {
        this->x=x;   
        this->y=y; 
    }
…..
};
```
```c++
Второй случай использования this

class List // Линейный односвязный список 
{
    int x; // инф. поле 
    List *pNext; // Указатель на след. элемент 
public: 
    List(int x) 
    {
        this->x=x;
    }
    void add(List *&pF) // Добавить элемент в начало списка 
    {
        pNext=pF; pF=this; // Текущий элемент будет первым
    }
…………….
};
```

### 6. Указатели на компоненты класса (на функции и поля класса), назначение, пример.


### 7. Дружественные функции и классы, назначение, пример.


### 8. Шаблоны классов в Си++. Примеры использования.


### 9. Перегрузка стандартных операций (унарных, бинарных) в случае, когда оператор-функция принадлежит классу, пример.


### 10. Перегрузка стандартных операций (унарных, бинарных) в случае, когда оператор-функция не принадлежит классу, пример.


### 11. Особенности перегрузки операций ++ и – в префиксной и постфиксной формах.

Перегрузка операций `++` и `--`, 
чтобы отличить `постфиксную` форму от `префиксной`, 
вводится формальный параметр типа `int`.

```c++
Пример объявления операторов-функций внутри класса:

Vector & operator++()  // Префиксная форма операции ++ 
Vector operator++(int) // Постфиксная форма операции ++ 
                       // всегда есть формальный (фиктивный)
                       // параметр типа int
                       
Пример объявления операторов-функций за пределами класса:

Vector & operator++(Vector & V) // Префиксная форма операции ++ 
Vector operator++(Vector & V, int)  // Постфиксная форма операции ++ 
                                    // всегда есть формальный 
                                    // (фиктивный) параметр типа int
                                    
```
В постфиксной форме вначале с помощью конструктора копирования создаем новый объект, 

в котором сохраняется начальное (старое) состояние текущего объекта, 

затем текущий объект изменяется, и возвращается созданный объект.


### 12. Особенности перемещения объекта, продемонстрировать пример перемещения при перегрузке операции «=» (присваивание) на примере своего класса вектор, содержащем в качестве поля динамический массив элементов типа int.


### 13. Наследование классов. Объявление производного класса, пример использования.


### 14. Статусы доступа при наследовании классов.


### 15. Конструкторы и деструктор в производных классах, примеры.


### 16. Множественное наследование и виртуальные базовые классы, примеры.


### 17. Переопределение функций при наследовании классов, виртуальные функции в Си++ (таблица виртуальных функций). Статическое и динамическое связывание. Примеры.


### 18. Абстрактные и локальные классы в Си++, примеры.


### 19. Требования к классам, объекты которых являются элементами последовательных контейнеров. Лямбда-функции в Си++. Использование лямбда-функций в алгоритмах. Сортировка контейнера алгоритмом sort с помощью предиката, лямбда-функции и перегрузки операции «<».


### 20. Функциональные объекты (функторы), перегрузка операции () (вызов функции) в классах, пример использования.


### 21. Требования к классам, объекты которых являются элементами контейнеров set и map.


### 22. Требования к классам, объекты которых являются элементами контейнеров unordered_set и unordered_map.


### 23. Понятие особой (исключительной) ситуации в Си++. Общий формат обработки исключительных ситуаций (ключевые слова: try, catch, throw).


### 24. Обработка исключения внутри функции, в которой сгенерировано исключение (ключевые слова: try, catch, throw), пример.


### 25. Обработка исключения вне функции, в которой сгенерировано исключение, объявление функции, в которой генерируются исключения (ключевые слова: try, catch, throw), пример.


### 26. Создание исключения как объекта класса в Си++ (ключевые слова: try, catch, throw), пример.


### 27. Формы обработчиков исключений (catch), примеры.


### 28. Формы выражений генерации исключений в Си++ (throw), примеры.


### 29. Обработка исключений в стандартной библиотеке Си++: обзор основных классов.


### 30. Обработка исключений в стандартной библиотеке Си++: создание своего класса исключения на основе класса std::exception, пример.


### 31. Многозадачность в стандартной библиотеке C++: высокоуровневый интерфейс (функция std::async() и шаблон класса std::future< >), пример создания потока и получение результата потоковой функции.


### 32. Многозадачность в стандартной библиотеке C++: низкоуровневый интерфейс (использование класса std::thread), пример.


### 33. Синхронизация в стандартной библиотеке C++. Использование класса std::mutex (взаимное исключение), пример.


### 34. Использование для синхронизации потоков блокировок – шаблона std::lock_guard, пример.


### 35. Использование условных переменных (объекты класса std::condition_variable) для синхронизации потоков в стандартной библиотеке C++: посылка и принятие оповещений потоками, примеры.


### 36. Использование атомарных операций (шаблон std::atomic) для синхронизации потоков в стандартной библиотеке C++.


### 37. Умный указатель (smart pointer) std::unique_ptr, внутреннее устройство, пример использования.


### 38. Умный указатель (smart pointer) std::shared_ptr, внутреннее устройство, пример использования.


### 39. Умный указатель (smart pointer) std::weak_ptr, назначение, пример использования.


### 40. Перегрузка операторов new и delete.


### 41. Размещающий оператор new и его перегрузка.


### 42. Передача дополнительных параметров в оператор new при его перегрузке.


### 43. Дополнительные операции преобразования типов: const_cast, dynamic_cast, static_cast, reinterpret_cast.


### 44. Понятие о динамической идентификации типов в Си++. Операция typeid. Основные функции класса typeinfo. Примеры использования.
