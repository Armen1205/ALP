1. Классы в языке Си++: объявление, поля и функции (методы) классов. Определение
функций внутри класса и за пределами класса, примеры.
2. Статусы доступа компонент класса. Операции для доступа к компонентам класса,
примеры.
3. Конструкторы и деструктор класса, конструктор копирования и конструктор
перемещения, назначение, пример.
4. Статические компоненты класса, назначение, пример.
5. Указатель this, примеры использования.
6. Указатели на компоненты класса (на функции и поля класса), назначение, пример.
7. Дружественные функции и классы, назначение, пример.
8. Шаблоны классов в Си++. Примеры использования.
9. Перегрузка стандартных операций (унарных, бинарных) в случае, когда оператор-
функция принадлежит классу, пример.
10. Перегрузка стандартных операций (унарных, бинарных) в случае, когда оператор-
функция не принадлежит классу, пример.
11. Особенности перегрузки операций ++ и – в префиксной и постфиксной формах.
12. Особенности перемещения объекта, продемонстрировать пример перемещения при
перегрузке операции «=» (присваивание) на примере своего класса вектор,
содержащем в качестве поля динамический массив элементов типа int.
13. Наследование классов. Объявление производного класса, пример использования.
14. Статусы доступа при наследовании классов.
15. Конструкторы и деструктор в производных классах, примеры.
16. Множественное наследование и виртуальные базовые классы, примеры.
17. Переопределение функций при наследовании классов, виртуальные функции в Си++
(таблица виртуальных функций). Статическое и динамическое связывание. Примеры.
18. Абстрактные и локальные классы в Си++, примеры.
19. Требования к классам, объекты которых являются элементами последовательных
контейнеров. Лямбда-функции в Си++. Использование лямбда-функций в алгоритмах.
Сортировка контейнера алгоритмом sort с помощью предиката, лямбда-функции и
перегрузки операции «<».
20. Функциональные объекты (функторы), перегрузка операции () (вызов функции) в
классах, пример использования.
21. Требования к классам, объекты которых являются элементами контейнеров set и map.
22. Требования к классам, объекты которых являются элементами контейнеров
unordered_set и unordered_map.
23. Понятие особой (исключительной) ситуации в Си++. Общий формат обработки
исключительных ситуаций (ключевые слова: try, catch, throw).
24. Обработка исключения внутри функции, в которой сгенерировано исключение
(ключевые слова: try, catch, throw), пример.
25. Обработка исключения вне функции, в которой сгенерировано исключение,
объявление функции, в которой генерируются исключения (ключевые слова: try, catch,
throw), пример.
26. Создание исключения как объекта класса в Си++ (ключевые слова: try, catch, throw),
пример.
27. Формы обработчиков исключений (catch), примеры.
28. Формы выражений генерации исключений в Си++ (throw), примеры.
29. Обработка исключений в стандартной библиотеке Си++: обзор основных классов.
30. Обработка исключений в стандартной библиотеке Си++: создание своего класса
исключения на основе класса std::exception, пример.
31. Многозадачность в стандартной библиотеке C++: высокоуровневый интерфейс
(функция std::async() и шаблон класса std::future< >), пример создания потока и
получение результата потоковой функции.
32. Многозадачность в стандартной библиотеке C++: низкоуровневый интерфейс
(использование класса std::thread), пример.
33. Синхронизация в стандартной библиотеке C++. Использование класса std::mutex
(взаимное исключение), пример.
34. Использование для синхронизации потоков блокировок – шаблона std::lock_guard,
пример.
35. Использование условных переменных (объекты класса std::condition_variable) для
синхронизации потоков в стандартной библиотеке C++: посылка и принятие
оповещений потоками, примеры.
36. Использование атомарных операций (шаблон std::atomic) для синхронизации потоков в
стандартной библиотеке C++.
37. Умный указатель (smart pointer) std::unique_ptr, внутреннее устройство, пример
использования.
38. Умный указатель (smart pointer) std::shared_ptr, внутреннее устройство, пример
использования.
39. Умный указатель (smart pointer) std::weak_ptr, назначение, пример использования.
40. Перегрузка операторов new и delete.
41. Размещающий оператор new и его перегрузка.
42. Передача дополнительных параметров в оператор new при его перегрузке.
43. Дополнительные операции преобразования типов: const_cast, dynamic_cast, static_cast,
reinterpret_cast.
44. Понятие о динамической идентификации типов в Си++. Операция typeid. Основные
функции класса typeinfo. Примеры использования.
